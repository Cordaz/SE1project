package it.polimi.ingsw.BianchiCorneo.supervisor;

import it.polimi.ingsw.BianchiCorneo.actions.Abandoned;
import it.polimi.ingsw.BianchiCorneo.actions.Action;
import it.polimi.ingsw.BianchiCorneo.actions.Killed;
import it.polimi.ingsw.BianchiCorneo.actions.ObjectUsed;
import it.polimi.ingsw.BianchiCorneo.maps.MAPConst;
import it.polimi.ingsw.BianchiCorneo.maps.Table;
import it.polimi.ingsw.BianchiCorneo.maps.cards.Card;
import it.polimi.ingsw.BianchiCorneo.maps.cards.Deck;
import it.polimi.ingsw.BianchiCorneo.maps.cards.DefenceCard;
import it.polimi.ingsw.BianchiCorneo.maps.cards.NoiseObj;
import it.polimi.ingsw.BianchiCorneo.maps.cards.ObjDeck;
import it.polimi.ingsw.BianchiCorneo.maps.cards.SectorCard;
import it.polimi.ingsw.BianchiCorneo.maps.cards.SectorDeck;
import it.polimi.ingsw.BianchiCorneo.maps.sectors.Sector;
import it.polimi.ingsw.BianchiCorneo.players.Alien;
import it.polimi.ingsw.BianchiCorneo.players.Human;
import it.polimi.ingsw.BianchiCorneo.players.Player;
import it.polimi.ingsw.BianchiCorneo.players.PlayerList;

import java.util.Map;
import java.util.Random;
import java.util.Timer;
import java.util.logging.Level;
import java.util.logging.Logger;


/**This class deals with the game, invokes the notifier and the turns' scheme
 * It will be exposed to Controller and ClientHandler classes
 * Every instance of this Object will handle a single game
 * @author Andrea Corneo
 *
 */
public class GameSupervisor implements Runnable, TimerInterface {
	private Table table;
	
	private Deck sectorDeck;
	private Deck objectDeck;
	
	private PlayerList playerList;
	private PlayerList activePlayerList = new PlayerList();
	private int curPlayer;
	private PlayerTurn playerTurn;
	
	private boolean waiting;
	private boolean gameValid;
	private boolean timeExceeded;
	
	private ClientMonitor clientMonitor;
	private Action action;
	private Object actionParam;
	private boolean notified;
	private boolean recordReady;
	
	private Timer timer;
	
	/**Constructor
	 * @param t table generated by the server
	 */
	public GameSupervisor(Table t) {
		waiting = true;
		gameValid = true;
		table = t;
		timeExceeded = false;
		clientMonitor = new ClientMonitor();
		notified = false;
	}
	
	/* (non-Javadoc)
	 * @see java.lang.Runnable#run()
	 */
	@Override
	public void run() {
		System.out.println("Starting supervisor");
		playerTurn = new PlayerTurn(playerList.size());
		curPlayer = playerTurn.nextPlayer();
		playerList.get(curPlayer).setPlaying(true);
		while (gameValid && playerTurn.getTurn()<40) {
			startTurn();
			
			while (playerList.get(curPlayer).isPlaying() && !timeExceeded && !notified && gameValid) {
				
				//Check if there is only one human remaining, if so sets his flag to true
				int j = 0, last = -1;
				for (int i = 0; i < activePlayerList.size(); i++)
					if (activePlayerList.get(i) instanceof Human) {
						j++;
						last = i;
					}
				if (j == 1)
					((Human)activePlayerList.get(last)).setLast();
				
				if (!activePlayerList.validGame()) {
					gameValid = false;
				}
				else 
					try {
						synchronized(this) {this.wait();}
					} catch (InterruptedException e) {
						Logger.getGlobal().log(Level.ALL, "Error.", e);
					}
				
				if (timeExceeded) {
					Player p = playerList.get(curPlayer);
					p.suspend();
					activePlayerList.remove(curPlayer);
					playerTurn.removePlayer(curPlayer);
					timeExceeded = false;
					clientMonitor.notifyAction(new Abandoned(p, "left the game"));
					changeTurn();
				}
				if (notified) {
					checkActionParam();
					clientMonitor.notifyAction(action);
					notified = false;
				}
				if (!playerList.get(curPlayer).isPlaying()){
					timer.cancel();
					changeTurn();
				}
			}
		}
		endGame();
	}
	
	/**Getter for player's turn boolean
	 * @param p player to check
	 * @return <b>true</b> if p can play, else <b>false</b>
	 */
	public boolean isYourTurn (Player p) {
		return playerList.get(curPlayer).equals(p);
	}
	
	/**Check what parameter has been passed with the action.
	 * Then it will call the correct method
	 * 
	 */
	private void checkActionParam() {
		if (actionParam instanceof PlayerList) { //There was an attack
			removeAttacker();
			int killed = killPlayers();
			handleAttacker(killed);
		}
		else if (actionParam instanceof Map) //param passed by lightOn()
			lightPlayers();
	}

	/**Hande the light on sector action
	 * 
	 */
	private void lightPlayers() {
		@SuppressWarnings("unchecked")
		Map<Player, Sector> playerMap = (Map<Player,Sector>)actionParam;
		for (int i=0; i<playerList.size(); i++)
			if (playerMap.containsKey(playerList.get(i)))
				clientMonitor.notifyAction(new Action(playerList.get(i), "is on sector " + playerMap.get(playerList.get(i))));
	}

	/**Remove the attacker from the player on the sector attacked to avoid suicide
	 * 
	 */
	private void removeAttacker() {
		Player attacker = action.who();
		((PlayerList)actionParam).remove(attacker);
	}

	/**Check if some human had been killed by an alien, if positive, set the alien to powerful
	 * @param killed number of human killed in the attack
	 */
	private void handleAttacker(int killed) {
		if (killed > 0 && action.who() instanceof Alien)
			((Alien)action.who()).becomePowerful();
	}

	/**Called for an attack, it will check if any player had a shield, then kill all the others
	 * 
	 */
	private int killPlayers() {
		int killed=0;
		PlayerList players = (PlayerList)actionParam;
		for (int i=0; i<players.size(); i++)
			for (int j=0; j<playerList.size(); j++) {
				if (players.get(i).equals(playerList.get(j)))
					if (playerList.get(j) instanceof Human)
						if (((Human)playerList.get(j)).hasShield()) {
							((Human)playerList.get(j)).resetShield();
							clientMonitor.notifyAction(new ObjectUsed(playerList.get(j), new DefenceCard()));
							reinsertCard(((Human)playerList.get(j)).rmDefence());
						} else {
							playerList.get(j).kill();
							table.updatePos(playerList.get(j), new Sector(MAPConst.KILLEDSECTOR));
							playerList.addEndInfo(playerList.get(j));
							killed++;
							clientMonitor.notifyAction(new Killed(playerList.get(j), "has been killed"));
							activePlayerList.remove(j);
							playerTurn.removePlayer(j);
						}
					else {
						playerList.get(j).kill();
						table.updatePos(playerList.get(j), new Sector(MAPConst.KILLEDSECTOR));
						playerList.addEndInfo(playerList.get(j));
						killed++;
						clientMonitor.notifyAction(new Killed(playerList.get(j), "has been killed"));
						activePlayerList.remove(j);
						playerTurn.removePlayer(j);
					}
			}
		
		/*if(!activePlayerList.validGame()) {
			gameValid = false; 						//IMPORTANT moved temporary before the wait in "run" method: to check, to fix 
			this.notifyAll();
		}*/
		
		return killed;
	}
	
	/**Standard getter for <code>gameValid</code>
	 * @return <b>true</b> if game is playable, else <b>false</b>
	 */
	public boolean isGameValid() {
		return gameValid;
	}
	
	/**Standard getter for <code>waiting</code>
	 * @return <b>true</b> if the game has'nt started yer, else <b>false</b>
	 */
	public boolean isWaiting() {
		return waiting;
	}
	
	/**Standard setter for <code>playerList</code> and <code>activePlayerList</code>
	 * @param pl list generated in the server
	 */
	public void setPlayerList(PlayerList pl) {
		playerList = pl;
		activePlayerList.copy(pl);
	}
	
	/**Standard getter for <code>playerList</code>
	 * @return game's playerList
	 */
	public PlayerList getPlayerList() {
		return playerList;
	}
	public PlayerList getActivePlayerList() {
		return activePlayerList;
	}
	public void removeFromPlayerTurn() {
		playerTurn.removePlayer(curPlayer);
	}
	
	/**Standard getter for <code>table</code>
	 * @return game's table
	 */
	public Table getTable() {
		return table;
	}
	
	/**Standard getter for <code>clientMonitor</code>
	 * @return game's clientMonitor
	 */
	public ClientMonitor getMonitor() {
		return clientMonitor;
	}
	
	/** Draw a sector card from the game deck, if it has an object linked it will be returned in cards[1], else it will be null.
	 * Return an instance of NoCardAvailable if the deck is empty
	 * @return cards[], cards[0] sectorCard, cards[1] the object if it exists
	 */
	public Card[] drawCard() {
		Card[] cards = new Card[2];
		cards[0] = sectorDeck.drawCard();
		if (cards[0] instanceof NoiseObj)
			cards[1] = objectDeck.drawCard();
		else
			cards[1] = null; //No object linked
		return cards;
	}
	
	/** Allow move to reinsert an used card into the correct deck
	 * @param c card to re-insert
	 */
	public void reinsertCard(Card c) {
		if (c instanceof SectorCard)
			sectorDeck.insertCard(c);
		else
			objectDeck.insertCard(c);
	}
	
	/** Allow Move to communicate what happened
	 * @param action what happened
	 * @param param if necessary, else is null
	 */
	public void notifySupervisor(Action action, Object param) {
		this.action = action;
		this.actionParam = param;
		notified = true;
		synchronized(this) {this.notifyAll();}
	}
	
	/**Set all the variables necessary for correctly starting the game
	 * 
	 */
	public void start() {
		waiting = false;
		gameValid = true;
	}
	
	/**Set the params to suspend the game
	 * 
	 */
	public void suspend() {
		waiting = false;
		gameValid = false;
	}
	
	/**Initialize the game, setting up the decks, placing the player on map and randomizing usable ship.
	 * 
	 */
	public void initGame() {
		sectorDeck = new SectorDeck();
		sectorDeck.initDeck();
		objectDeck = new ObjDeck();
		objectDeck.initDeck();
		for (int i = 0; i < playerList.size(); i++)
			playerList.get(i).placeOnMap();
		table.initShip();
	}


	/**Change cur player, if there aren't at least one human and one alien stop the game
	 * 
	 */
	private void changeTurn () {
		if(!activePlayerList.validGame()) {
			gameValid = false;
		} else {		
			curPlayer = playerTurn.nextPlayer();
			playerList.get(curPlayer).setPlaying(true);
		}
	}
	
	
	/**Start he timer and reset player's variable for starting the new turn
	 * 
	 */
	private void startTurn () {
		if (playerList.get(curPlayer).hasMadeNoise())
			playerList.get(curPlayer).hasMadeNoiseOn().stopNoise();
		timer = new Timer();
		timer.schedule(new MyTimer(this), SVConst.TIMEOUTTURN);
	}
	
	/**Generates the end message and wait for the client to get notified
	 * 
	 */
	private void endGame() {
		record();
		waitConclusion();
	}

	/**Wait for the client to get notified at the end of the game
	 * 
	 */
	private void waitConclusion() {
		timer = new Timer();
		timer.schedule(new MyTimer(this), SVConst.TIMECONCLUSION);
		while(!timeExceeded) {
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				Logger.getGlobal().log(Level.ALL, "Error.", e);
			}
		}
	}

	/**Check the winner and construct a formatted string, then notifies the client via clientMonitor
	 * 
	 */
	private void record() {
		String record = SVConst.ENDGAME;
		
		String win = playerList.giveWinner();
		if (win != "")
			record = record + "  " + SVConst.WIN + win + "\n\n";
		String killed = playerList.giveKilled();
		if (killed != "")
			record = record + "  " + SVConst.KILLED + killed + "\n";
		
		for (int i = 0; i < playerList.size(); i++) {
			if (playerList.get(i) instanceof Human) {
				if ((((Human)playerList.get(i)).isLast() && !playerList.get(i).isAlive()) ||
						(((Human)playerList.get(i)).isLast() && playerList.get(i).isAlive() && !playerList.get(i).getCurSector().sameAs(new Sector(MAPConst.WINNINGSECTOR))))
					record = record + "\n  Alien squad wins";
			}
		}
		recordReady = true;
		clientMonitor.notifyEnd(record);
	}

	/* (non-Javadoc)
	 * @see it.polimi.ingsw.BianchiCorneo.supervisor.TimerInterface#setTimeExceeded()
	 */
	@Override
	public void setTimeExceeded() {
		timeExceeded = true;
		synchronized(this) {this.notifyAll();}
	}

	/**Standard getter for <code>recordReady</code>
	 * @return <b>true</b> if string message end has been created, <b>false</b> otherwise
	 */
	public boolean isRecordReady() {
		return recordReady;
	}
	
}

/**This inner class is used to avoid the fact that the player are ordered.
 * It provides a different turn alternation, casually generated.
 * @author Andrea Corneo
 *
 */
class PlayerTurn  {
	private int turn;
	private int[] playerTurn;
	private int cur;
	
	
	/**Constructor, it instantiate a <code>dim</code>-array (number of players)
	 * @param dim
	 */
	PlayerTurn(int dim) {
		playerTurn = new int[dim];
		initTurn();
		cur = 0;
		turn = 1;
	}


	/**Initializes the turn alternation, randomizing it
	 * 
	 */
	private void initTurn() {
		for (int i=0; i<playerTurn.length; i++)
			playerTurn[i] = i;
		int tmp, k, h;
		Random rnd = new Random();
		//Shuffle
		for (int j=0; j<20; j++) {
			k = rnd.nextInt(playerTurn.length);
			tmp = playerTurn[k];
			h = rnd.nextInt(playerTurn.length);
			playerTurn[k] = playerTurn[h];
			playerTurn[h] = tmp;
		}
	}
	
	/**Standard getter for <code>turn</code>
	 * @return turn number
	 */
	int getTurn() {
		return turn;
	}
	
	/**Standard getter for next player, it ensures that the player is in.
	 * @return player's index in playerList
	 */
	int nextPlayer() {
		if (playerTurn.length == 1)
			return playerTurn[0];
		
		int k = playerTurn[cur];
		cur++;
		if (cur == playerTurn.length) {
			cur = 0;
			turn++;
		}
		return k;
	}
	
	/**Remove a player from active playing, ignoring him in turn alternation
	 * @param index in playerList of the player to remove
	 */
	void removePlayer(int index) {
		int[] support = new int[playerTurn.length - 1];
		int i=0;
		
		for(int x : playerTurn)
			if (x!=index) {
				support[i] = x;
				i++;
			}
	}
}
